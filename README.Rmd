---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
library(importAs)
```

# importAs

This package helps mimic the idiomatic python importing of packages such as

```{python, eval = FALSE}
import dplyr as d
```

In order to mimic this as closely as possible, the function `importAs` takes a 
package name and a (short?) name for that and creates a linkage

```{r}
importAs("dplyr", "d")
```

This is merely a convenience, however. In reality a variable `d` is created 
with the value `"dplyr"`, so we could also do this manually for another package

```{r}
s <- "stringr"
```

The `importAs` function is merely a signal to a reader that this magic is going to 
be performed.

At this point nothing magical has happened. The magic comes from overwriting the `::`
operator. To -- at least, my -- surprise, `::` can happily take a character argument 
for the left-hand side, so 

```{r}
## equivalent to "dplyr"::filter
base::`::`("dplyr", filter)
```

works. The magic part is rewriting this function to look deeper if provided with a 
symbol which already resolves to a character string representing an installed 
package. The result is that we can shorthand the namespace referencing

```{r}
d::filter(mtcars, cyl == 4, am == 1)
s::str_extract("a1b2c3", "[a-z]2")
```

without interfering with any existing functionality

```{r}
dplyr::filter(mtcars, cyl == 4, am == 1)
stringr::str_extract("a1b2c3", "[a-z]2")
```

## Installation

You can install the development version of `importAs` with

```{r, eval = FALSE}
## install.packages("devtools")
devtools::install_github("jonocarroll/importAs")
```
